<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>OrumGS · Mercados</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet"/>
  <link rel="stylesheet" href="style.css"/>
  <style>
    .price-up { transition: color .25s ease; color: #16a34a; }   /* green-600 */
    .price-down { transition: color .25s ease; color: #dc2626; } /* red-600 */
  </style>
</head>
<body class="bg-gray-100">
  <div id="app">
    <!-- NAV -->
    <nav class="bg-white shadow-md">
      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between h-16 items-center">
          <div class="flex items-center gap-8">
            <h1 class="text-2xl font-bold text-blue-800">OrumGS</h1>
            <a href="Inicio.html" class="text-gray-900 hover:bg-gray-200 px-3 py-2 rounded-md text-sm font-medium">Inicio</a>
            <a href="Mercados.html" class="text-gray-900 hover:bg-gray-200 px-3 py-2 rounded-md text-sm font-medium">Mercados</a>
            <a href="Administracion.html" class="text-gray-900 hover:bg-gray-200 px-3 py-2 rounded-md text-sm font-medium"
               v-if="userRole === 'Dueño' || userRole === 'Gerente' || userRole === 'Trabajador'">Administración</a>
          </div>
          <div class="flex items-center gap-4">
            <span class="text-gray-700 font-semibold" v-if="userRole">{{ userRole }}</span>
            <button @click="logout" class="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 transition">Cerrar Sesión</button>
          </div>
        </div>
      </div>
    </nav>

    <!-- CONTENIDO -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-8">
      <div class="flex items-center justify-between mb-6">
        <h2 class="text-3xl font-bold text-blue-900">Mercados en Vivo</h2>
        <div class="text-sm text-gray-600" v-if="lastUpdatedPrices">Precios: {{ timeFmt(lastUpdatedPrices) }}</div>
      </div>

      <!-- Selectores -->
      <div class="grid md:grid-cols-3 gap-4 mb-6">
        <div v-for="(card, i) in cards" :key="'sel-'+i" class="bg-white p-4 rounded-lg shadow">
          <label class="block text-sm font-medium text-gray-700 mb-1">Instrumento #{{ i+1 }}</label>
          <select class="w-full border rounded px-3 py-2"
                  v-model="card.key"
                  @change="onSelectionChange(i)">
            <option v-for="it in instruments" :key="it.key" :value="it.key">
              {{ it.label }}
            </option>
          </select>
        </div>
      </div>

      <!-- Tarjetas de mercado -->
      <div class="grid md:grid-cols-3 gap-6">
        <div v-for="(card, i) in cards" :key="'card-'+i" class="bg-white rounded-xl shadow p-5">
          <div class="flex items-baseline justify-between mb-2">
            <h3 class="text-lg font-semibold text-gray-900">{{ labelFor(card.key) }}</h3>
            <span class="text-xs text-gray-500" v-if="updatedAt[i]">Act.: {{ timeFmt(updatedAt[i]) }}</span>
          </div>

          <div class="flex items-center justify-between">
            <div>
              <div :class="priceDirClass(i)" class="text-2xl font-bold">
                {{ priceDisplay(prices[i]) }}
              </div>
              <div class="text-sm text-gray-500" v-if="prices[i]Prev != null">
                Anterior: {{ priceDisplay(prices[i]Prev) }}
              </div>
            </div>

            <!-- Flecha up/down -->
            <div class="text-3xl select-none">
              <span v-if="priceDirection[i] === 'up'">↑</span>
              <span v-else-if="priceDirection[i] === 'down'">↓</span>
              <span v-else>·</span>
            </div>
          </div>

          <!-- RSI + Etiqueta -->
          <div class="mt-4 p-3 rounded-lg bg-gray-50 border">
            <div class="flex items-center justify-between">
              <div class="text-sm text-gray-600">
                RSI(14, 1min): <span :class="rsiClass(rsi[i])">{{ rsiDisplay(rsi[i]) }}</span>
              </div>
              <div class="text-sm font-semibold" :class="rsiClass(rsi[i])">
                {{ rsiLabel(rsi[i]) }}
              </div>
            </div>
          </div>

          <!-- Estado / errores -->
          <div class="text-xs mt-3 text-gray-500" v-if="cardError[i]">
            ⚠️ {{ cardError[i] }}
          </div>
        </div>
      </div>

      <!-- Mensaje global -->
      <div class="mt-6 text-sm text-gray-600" v-if="globalMsg">{{ globalMsg }}</div>
    </main>
  </div>

  <script>
    const { createApp } = Vue;
    const API_URL = ''; // mismo origen
    const PRICE_POLL_MS = 15000; // 15s (el backend cachea 60s → no quema créditos en exceso)
    const RSI_POLL_MS   = 60000; // 60s

    createApp({
      data() {
        return {
          userRole: localStorage.getItem('userRole') || 'Dueño',
          instruments: [],     // viene de /top30-list (ahora TOP20)
          cards: [
            { key: 'BTCUSDT' },
            { key: 'ETHUSDT' },
            { key: 'EURUSD'  },
          ],
          prices: [null, null, null],
          pricesPrev: [null, null, null],
          priceDirection: [null, null, null],
          updatedAt: [null, null, null],
          rsi: [null, null, null],
          cardError: [null, null, null],
          lastUpdatedPrices: null,
          globalMsg: '',
          updateInterval: null,
          rsiInterval: null,
        };
      },
      mounted() {
        this.checkLoginStatus();
      },
      beforeUnmount() {
        this.stopUpdates();
      },
      methods: {
        logout() {
          localStorage.removeItem('token');
          localStorage.removeItem('userRole');
          window.location.href = 'index.html';
        },
        async checkLoginStatus() {
          try {
            // Carga instrumentos
            await this.loadInstruments();
            // Primera carga
            await this.fetchPrices();
            await this.fetchRSI();
            // Timers
            this.startUpdates();
          } catch (e) {
            console.error('init error', e);
            this.globalMsg = 'No fue posible inicializar mercados.';
          }
        },
        async loadInstruments() {
          try {
            const r = await fetch(`${API_URL}/top30-list`);
            if (!r.ok) throw new Error('HTTP '+r.status);
            const list = await r.json();
            this.instruments = list || [];
            // valida selecciones por si no existen ya
            this.cards = this.cards.map(c => {
              const ok = this.instruments.find(it => it.key === c.key);
              return ok ? c : { key: this.instruments[0]?.key || 'BTCUSDT' };
            });
          } catch (e) {
            console.error('loadInstruments', e);
            this.instruments = [
              { key:'BTCUSDT', label:'BTCUSDT (Bitcoin)', type:'crypto' },
              { key:'ETHUSDT', label:'ETHUSDT (Ethereum)', type:'crypto' },
              { key:'EURUSD',  label:'EURUSD', type:'forex' },
            ];
          }
        },
        labelFor(key) {
          const it = this.instruments.find(x => x.key === key);
          return it ? it.label : key;
        },
        priceDisplay(v) {
          if (typeof v !== 'number' || !isFinite(v)) return '—';
          const decimals = v < 1 ? 6 : 2;
          return '$ ' + v.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
        },
        timeFmt(ts) {
          const d = new Date(ts);
          return d.toLocaleTimeString();
        },
        priceDirClass(i) {
          return this.priceDirection[i] === 'up' ? 'price-up' :
                 this.priceDirection[i] === 'down' ? 'price-down' : '';
        },
        rsiClass(v) {
          if (!(typeof v === 'number' && isFinite(v))) return 'text-gray-500';
          if (v >= 60) return 'text-green-600';
          if (v <= 40) return 'text-red-600';
          return 'text-yellow-600';
        },
        rsiLabel(v) {
          if (!(typeof v === 'number' && isFinite(v))) return 'sin datos';
          if (v >= 60) return 'mercado alcista';
          if (v <= 40) return 'mercado bajista';
          return 'mercado neutro';
        },
        rsiDisplay(v) {
          if (typeof v !== 'number' || !isFinite(v)) return '—';
          return v.toFixed(1);
        },

        async fetchPrices() {
          try {
            this.globalMsg = '';
            const keys = this.cards.map(c => c.key).join(',');
            const url = `${API_URL}/market-prices?keys=${encodeURIComponent(keys)}`;
            const r = await fetch(url, { cache: 'no-store' });
            if (!r.ok) throw new Error('HTTP '+r.status);
            const j = await r.json();
            const byKey = Object.fromEntries((j.items||[]).map(it => [it.key, it.price_usd]));

            this.cards.forEach((c, i) => {
              const val = byKey[c.key];
              // mantiene prev para dirección
              const prev = this.prices[i];
              this.pricesPrev[i] = prev;
              if (typeof val === 'number' && isFinite(val)) {
                this.prices[i] = val;
                if (typeof prev === 'number') {
                  this.priceDirection[i] = val > prev ? 'up' : (val < prev ? 'down' : null);
                }
                this.cardError[i] = null;
              } else {
                this.cardError[i] = 'Sin precio disponible';
              }
              this.updatedAt[i] = Date.now();
            });
            this.lastUpdatedPrices = Date.now();
          } catch (e) {
            console.error('fetchPrices', e);
            this.globalMsg = 'No se pudieron actualizar los precios. Reintentando…';
          }
        },

        async fetchRSI() {
          try {
            const keys = this.cards.map(c => c.key).join(',');
            const url = `${API_URL}/indicators/rsi?keys=${encodeURIComponent(keys)}&interval=1min&period=14`;
            const r = await fetch(url, { cache: 'no-store' });
            if (!r.ok) throw new Error('HTTP '+r.status);
            const j = await r.json();
            const byKey = Object.fromEntries((j.items||[]).map(it => [it.key, it.rsi]));
            this.cards.forEach((c, i) => {
              const v = byKey[c.key];
              this.rsi[i] = (typeof v === 'number' && isFinite(v)) ? v : null;
            });
          } catch (e) {
            console.error('fetchRSI', e);
            // no mostramos error global para RSI; conservamos último valor
          }
        },

        onSelectionChange(i) {
          // Pequeño debounce para no hacer 2 llamadas si el usuario cambia varios selects
          if (this._selTimer) clearTimeout(this._selTimer);
          this._selTimer = setTimeout(async () => {
            await this.fetchPrices();
            await this.fetchRSI();
          }, 300);
        },

        startUpdates() {
          this.stopUpdates();
          // ⚠️ usar arrow functions para no perder "this"
          this.updateInterval = setInterval(() => this.fetchPrices(), PRICE_POLL_MS);
          this.rsiInterval    = setInterval(() => this.fetchRSI(), RSI_POLL_MS);
        },
        stopUpdates() {
          if (this.updateInterval) clearInterval(this.updateInterval);
          if (this.rsiInterval) clearInterval(this.rsiInterval);
          this.updateInterval = null;
          this.rsiInterval = null;
        },
      }
    }).mount('#app');
  </script>
</body>
</html>
